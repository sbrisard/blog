# -*- coding: utf-8; -*-
#+SETUPFILE: "../include/css-1.org"
#+TITLE: On the periodic-plus-smooth decomposition of an image, part 2: defining the decomposition
#+DATE: [2017-10-02 Mon]
#+LINK: moisan2011   https://doi.org/10.1007/s10851-010-0227-1
#+LINK: sb-blog-prev ./On_the_periodic-plus-smooth_decomposition_of_an_image-01.org
#+LINK: sb-blog-next ./On_the_periodic-plus-smooth_decomposition_of_an_image-03.org
#+LINK: sb-blog-data-dir ./On_the_periodic-plus-smooth_decomposition_of_an_image/
#+PROPERTY: header-args:ipython :session :eval no-export :exports both
#+MACRO: inline_mathml @@html: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">$1</math>@@

In the [[sb-blog-prev:][previous instalment]] of this series, I discussed the need for periodic
images. Although not all images are periodic, some image analysis techniques are
best performed in Fourier space (using the fast Fourier transform). Applying
Fourier-based techniques to images that are /not/ periodic (as is often the
case) generates artifacts. In order to reduce these artifacts, Moisan ([[moisan2011:][2011]])
proposed to construct a periodic image that is as close as possible to the
original image. For reasons that will become clearer in the remainder of this
post, he called the resulting construction the “periodic-plus-smooth
decomposition”. In this post, I will define this decomposition, a first
implementation of which will be proposed in the [[sb-blog-next:][next instalment]].

As an appetizer, Figure [[fig:1]] shows the original image (left) and its periodic
(middle) and smooth components (right). Gray levels of the smooth component have
been rescaled so as to fit between 0 and 255. Most of this image is grayish,
meaning it is zero almost everywhere, except at the boundaries, where it
corrects the jumps induced by the lack of periodicity of the initial image.

#+HEADER: :var DATA_DIR=(cdr (assoc "sb-blog-data-dir" org-link-abbrev-alist-local))
#+BEGIN_SRC ipython :results none :exports none
  import numpy as np
  import scipy.misc

  u = scipy.misc.imread(DATA_DIR+'hut-648x364.png')
  u = u.astype(np.float64)

  from moisan2011 import per_ref as per
  p = per(u, inverse_fft=True)
  s = u-p

  p = p.astype(np.uint8)
  s_min, s_ptp = s.min(), s.ptp()
  s = (255*(s-s_min)/s_ptp).astype(np.uint8)

  scipy.misc.imsave(DATA_DIR+'hut-648x364-periodic.png', p)
  scipy.misc.imsave(DATA_DIR+'hut-648x364-smooth.png', s)
  scipy.misc.imsave(DATA_DIR+'hut-648x364-periodic-fftshift.png',
                    np.fft.fftshift(p))

  margin = 20
  m, n = u.shape
  img = np.empty((m, 3*n+2*margin), dtype=np.uint8)
  img[:, :] = 255
  img[:, :n] = u
  img[:, n+margin:2*n+margin] = p
  img[:, 2*n+2*margin:3*n+2*margin] = s
  scipy.misc.imsave(DATA_DIR+'hut-648x364-periodic-plus-smooth.png', img)
#+END_SRC

#+CAPTION: Illustration of the periodic-plus-smooth decomposition of an image.
#+CAPTION: The original image (left), its periodic component (middle) and its
#+CAPTION: smooth (rescaled) component (right).
#+NAME: fig:1
#+ATTR_HTML: :width 100%
[[sb-blog-data-dir:hut-648x364-periodic-plus-smooth.png]]

Now, let us define this decomposition. The intuitive idea is the following: let
{{{inline_mathml(<mi>u</mi>)}}} be a
{{{inline_mathml(<mi>m</mi><mo>×</mo><mi>n</mi>)}}} image. The problem is to
find two images {{{inline_mathml(<mi>p</mi>)}}} (“periodic” component) and
{{{inline_mathml(<mi>s</mi>)}}} (“smooth” component), such that
{{{inline_mathml(<mi>u</mi><mo>=</mo><mi>p</mi><mo>+</mo><mi>s</mi>)}}}, and

  1. {{{inline_mathml(<mi>p</mi>)}}} minimizes jumps across boundaries
     (periodicity),
  2. {{{inline_mathml(<mi>s</mi>)}}} minimizes jumps between neighbor pixels
     (smoothness),
  3. {{{inline_mathml(<mi>p</mi>)}}} and {{{inline_mathml(<mi>u</mi>)}}} have
     same mean value (conservation of brigthness).

In the present post, neighbor pixels refer to the [[https://en.wikipedia.org/wiki/Pixel_connectivity#4-connected][4-connectivity]]. Furthermore,
we define

  - /direct/ neighbors, that are adjacent to the pixel under consideration
  - /indirect/ neighbors, that are periodic images of these neigbors that would
    normally fall outside the image.

Figure [[fig:direct_and_indirect_neighbors]] illustrates direct and indirect
neighbors. It shows that

  - corner pixels have 2 direct neighbors and 2 indirect neighbors,
  - off-corner, boundary pixels have 3 direct neighbors and 1 indirect neighbor,
  - off-boundary (inner) pixels have 4 direct neighbors.

#+CAPTION: Direct (blue) and indirect (green) neighbors of corner pixels
#+CAPTION: (orange, top row), off-corner, boundary pixels (orange, middle row)
#+CAPTION: and off-boundary pixels (orange, bottom row).
#+NAME: fig:direct_and_indirect_neighbors
#+ATTR_HTML: :width 90%
[[sb-blog-data-dir:direct_and_indirect_neighbors.svg]]

Now, we need to quantify how periodic is the periodic component
{{{inline_mathml(<mi>p</mi>)}}}, and how smooth is the smooth component
{{{inline_mathml(<mi>s</mi>)}}}. To do so, we will define two energy functions:
{{{inline_mathml(<mi>E</mi><msub><mtext>p</mtext></msub>)}}} and
{{{inline_mathml(<mi>E</mi><msub><mtext>s</mtext></msub>)}}} that penalize lack
of periodicity and smoothness, respectively. More precisely, $E_\mathrm{p}$
(resp. $E_\mathrm{s}$) is greater for less periodic (resp. less smooth) $p$
(resp. $s$). The periodic-plus-smooth decomposition of an image $u$ is then
defined as the pair of images $(p,s)$ that minimize the total energy $E(p,
s)=E_\mathrm{p}(p)+E_\mathrm{s}(s)$ under the constraints $u=p+s$ and
$\operatorname{mean}(s)=0$. The remainder of this post is dedicated to defining
the energies $E_\mathrm{p}$ and $E_\mathrm{s}$.

Regarding periodicity, first. For each pixel located at the boundary of an
image, we look at its periodic neighbors and compute the difference in gray
value. The measure of periodicity is defined as the sum of squares of these
differences. Note that “periodic neighbors” that are adjacent to the pixel under
consideration are excluded from this sum, as we focus here on the jumps accross
image boundaries. This leads to the following expression

\begin{align*}
E_\mathrm{p}(p)={}
&\bigl(p_{m-1, 0}-p_{0, 0}\bigr)^2+\bigl(p_{0, n-1}-p_{0, 0}\bigr)^2\\
&+\bigl(p_{0, 0}-p_{0, n-1}\bigr)^2+\bigl(p_{m-1, n-1}-p_{0, n-1}\bigr)^2\\
&+\bigl(p_{0, 0}-p_{m-1, 0}\bigr)^2+\bigl(p_{m-1, n-1}-p_{m-1, 0}\bigr)^2\\
&+\bigl(p_{0, n-1}-p_{m-1, n-1}\bigr)^2+\bigl(p_{m-1, 0}-p_{m-1, n-1}\bigr)^2\\
&+\sum_{i=1}^{m-2}\bigl(p_{i, n-1}-p_{i, 0}\bigr)^2
+\sum_{i=1}^{m-2}\bigl(p_{i, 0}-p_{i, n-1}\bigr)^2\\
&+\sum_{j=1}^{n-2}\bigl(p_{m-1, j}-p_{0, j}\bigr)^2
+\sum_{j=1}^{n-2}\bigl(p_{0, j}-p_{m-1, j}\bigr)^2,
\end{align*}

where the four first lines are the contributions of: the top-left, top right,
bottom left and bottom right corners, respectively. The fifth line is the
contribution of the left and right columns, and the sixth line is the
contribution of the top and bottom rows respectively. The above expression
reduces as follows

\begin{equation}
E_\mathrm{p}(p)
=2\sum_{j=0}^{n-1}\bigl(p_{m-1, j}-p_{0, j}\bigr)^2
+2\sum_{j=0}^{n-1}\bigl(p_{0, j}-p_{m-1, j}\bigr)^2.
\end{equation}

Now, smoothness is evaluated by computing the sum of squares of all jumps
between “true” (adjacent) neighbors: periodic images are excluded. This leads to the following expression

\begin{equation}
E_\mathrm{s}(s)=\sum_{i=0}^{m-1}\sum_{j=0}^{n-1}\Bigl[
\bigl(s_{i, j-1}-s_{i, j}\bigr)^2
+\bigl(s_{i, j+1}-s_{i, j}\bigr)^2
+\bigl(s_{i-1, j}-s_{i, j}\bigr)^2
+\bigl(s_{i+1, j}-s_{i, j}\bigr)^2\Bigr],
\end{equation}

where it is agreed that

\begin{equation}
s_{-1, j}=s_{m, j}=s_{i, -1}=s_{i, n}=0.
\end{equation}

#+BEGIN_SRC ipython :results output
  import numpy as np
  import sympy

  from scipy.ndimage import convolve

  k = np.array([[0, -1, 0],
                [-1, 4, -1],
                [0, -1, 0]], dtype=np.int32)

  m, n = 4, 5
  u = np.zeros((m, n), dtype=np.int32)

  output = sympy.zeros(m, n)
  for i in range(m):
      for j in range(n):
          u[i, j] = 1
          u_ij = sympy.Symbol('u{}{}'.format(i, j))
          output += u_ij*sympy.Matrix(convolve(u,k, mode='nearest'))
          u[i, j] = 0
  print(sympy.printing.mathml(output))
#+END_SRC

#+RESULTS:
: <matrix><matrixrow><apply><minus/><apply><minus/><apply><times/><cn>2</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>00</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>01</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>10</mml:mi></mml:msub></ci></apply><apply><plus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>00</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>01</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>02</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>11</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>01</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>02</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>03</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>12</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>02</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>03</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>04</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>13</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>03</mml:mi></mml:msub></ci></apply><apply><minus/><apply><times/><cn>2</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>04</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>14</mml:mi></mml:msub></ci></apply></apply></matrixrow><matrixrow><apply><plus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>00</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>10</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>11</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>20</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>01</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>10</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>4</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>11</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>12</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>21</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>02</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>11</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>4</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>12</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>13</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>22</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>03</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>12</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>4</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>13</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>14</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>23</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>04</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>13</mml:mi></mml:msub></ci></apply><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>14</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>24</mml:mi></mml:msub></ci></apply></apply></matrixrow><matrixrow><apply><plus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>10</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>20</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>21</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>30</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>11</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>20</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>4</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>21</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>22</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>31</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>12</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>21</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>4</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>22</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>23</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>32</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>13</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>22</mml:mi></mml:msub></ci></apply><apply><minus/><apply><minus/><apply><times/><cn>4</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>23</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>24</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>33</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>14</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>23</mml:mi></mml:msub></ci></apply><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>24</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>34</mml:mi></mml:msub></ci></apply></apply></matrixrow><matrixrow><apply><plus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>20</mml:mi></mml:msub></ci></apply><apply><minus/><apply><times/><cn>2</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>30</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>31</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>21</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>30</mml:mi></mml:msub></ci></apply><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>31</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>32</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>22</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>31</mml:mi></mml:msub></ci></apply><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>32</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>33</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>23</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>32</mml:mi></mml:msub></ci></apply><apply><minus/><apply><times/><cn>3</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>33</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>34</mml:mi></mml:msub></ci></apply></apply><apply><plus/><apply><minus/><apply><minus/><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>24</mml:mi></mml:msub></ci></apply><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>33</mml:mi></mml:msub></ci></apply><apply><times/><cn>2</cn><ci><mml:msub><mml:mi>u</mml:mi><mml:mi>34</mml:mi></mml:msub></ci></apply></apply></matrixrow></matrix>

# Local Variables:
# eval: (sb-blog-init-data-dir)
# fill-column: 80
# End:
