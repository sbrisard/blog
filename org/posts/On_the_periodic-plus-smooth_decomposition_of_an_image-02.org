# -*- coding: utf-8; -*-
#+SETUPFILE: "../include/css-1.org"
#+TITLE: On the periodic-plus-smooth decomposition of an image, part 2: defining the decomposition
#+DATE: [2017-10-02 Mon]
#+LINK: moisan2011   https://doi.org/10.1007/s10851-010-0227-1
#+LINK: sb-blog-prev ./On_the_periodic-plus-smooth_decomposition_of_an_image-01.org
#+LINK: sb-blog-next ./On_the_periodic-plus-smooth_decomposition_of_an_image-03.org
#+LINK: sb-blog-data-dir ./On_the_periodic-plus-smooth_decomposition_of_an_image/
#+PROPERTY: header-args:ipython :session :eval no-export :exports both
#+MACRO: inline_mathml @@html: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">$1</math>@@

In the [[sb-blog-prev:][previous instalment]] of this series, I discussed the need for periodic
images. Although not all images are periodic, some image analysis techniques are
best performed in Fourier space (using the fast Fourier transform). Applying
Fourier-based techniques to images that are /not/ periodic (as is often the
case) generates artifacts. In order to reduce these artifacts, Moisan ([[moisan2011:][2011]])
proposed to construct a periodic image that is as close as possible to the
original image. For reasons that will become clearer in the remainder of this
post, he called the resulting construction the “periodic-plus-smooth
decomposition”. In this post, I will define this decomposition, a first
implementation of which will be proposed in the [[sb-blog-next:][next instalment]].

As an appetizer, Figure [[fig:1]] shows the original image (left) and its periodic
(middle) and smooth components (right). Gray levels of the smooth component have
been rescaled so as to fit between 0 and 255. Most of this image is grayish,
meaning it is zero almost everywhere, except at the boundaries, where it
corrects the jumps induced by the lack of periodicity of the initial image.

#+HEADER: :var DATA_DIR=(cdr (assoc "sb-blog-data-dir" org-link-abbrev-alist-local))
#+BEGIN_SRC ipython :results none :exports none
  import numpy as np
  import scipy.misc

  u = scipy.misc.imread(DATA_DIR+'hut-648x364.png')
  u = u.astype(np.float64)

  from moisan2011 import per_ref as per
  p = per(u, inverse_fft=True)
  s = u-p

  p = p.astype(np.uint8)
  s_min, s_ptp = s.min(), s.ptp()
  s = (255*(s-s_min)/s_ptp).astype(np.uint8)

  scipy.misc.imsave(DATA_DIR+'hut-648x364-periodic.png', p)
  scipy.misc.imsave(DATA_DIR+'hut-648x364-smooth.png', s)
  scipy.misc.imsave(DATA_DIR+'hut-648x364-periodic-fftshift.png',
                    np.fft.fftshift(p))

  margin = 20
  m, n = u.shape
  img = np.empty((m, 3*n+2*margin), dtype=np.uint8)
  img[:, :] = 255
  img[:, :n] = u
  img[:, n+margin:2*n+margin] = p
  img[:, 2*n+2*margin:3*n+2*margin] = s
  scipy.misc.imsave(DATA_DIR+'hut-648x364-periodic-plus-smooth.png', img)
#+END_SRC

#+CAPTION: Illustration of the periodic-plus-smooth decomposition of an image.
#+CAPTION: The original image (left), its periodic component (middle) and its
#+CAPTION: smooth (rescaled) component (right).
#+NAME: fig:1
#+ATTR_HTML: :width 100%
[[sb-blog-data-dir:hut-648x364-periodic-plus-smooth.png]]

* The decomposition as a minimization problem

Let {{{inline_mathml(<mi>u</mi>)}}} be a
{{{inline_mathml(<mi>m</mi><mo>×</mo><mi>n</mi>)}}} image. We want to find two
images {{{inline_mathml(<mi>p</mi>)}}} (“periodic” component) and
{{{inline_mathml(<mi>s</mi>)}}} (“smooth” component), such that
{{{inline_mathml(<mi>u</mi><mo>=</mo><mi>p</mi><mo>+</mo><mi>s</mi>)}}}, and

  1. {{{inline_mathml(<mi>p</mi>)}}} minimizes jumps across boundaries
     (periodicity),
  2. {{{inline_mathml(<mi>s</mi>)}}} minimizes jumps between neighbor pixels
     (smoothness),
  3. {{{inline_mathml(<mi>p</mi>)}}} and {{{inline_mathml(<mi>u</mi>)}}} have
     same mean value (conservation of brigthness).

In Moisan's work, neighbor pixels refer to the [[https://en.wikipedia.org/wiki/Pixel_connectivity#4-connected][4-connectivity]]. Furthermore, we
define

  - /direct/ neighbors, that are adjacent to the pixel under consideration
  - /indirect/ neighbors, that are periodic images of these neigbors that would
    normally fall outside the image.

Figure [[fig:direct_and_indirect_neighbors]] illustrates direct and indirect
neighbors. It shows that

  - corner pixels have 2 direct neighbors and 2 indirect neighbors,
  - off-corner, boundary pixels have 3 direct neighbors and 1 indirect neighbor,
  - off-boundary (inner) pixels have 4 direct neighbors.

#+CAPTION: Direct (blue) and indirect (green) neighbors of corner pixels
#+CAPTION: (orange, top row), off-corner, boundary pixels (orange, middle row)
#+CAPTION: and off-boundary pixels (orange, bottom row).
#+NAME: fig:direct_and_indirect_neighbors
#+ATTR_HTML: :width 90%
[[sb-blog-data-dir:direct_and_indirect_neighbors.svg]]

Now, we need to quantify how periodic is {{{inline_mathml(<mi>p</mi>)}}}, and
how smooth is {{{inline_mathml(<mi>s</mi>)}}}. To do so, we will define two
energy functions: {{{inline_mathml(<msub><mi>E</mi><mtext>p</mtext></msub>)}}}
and {{{inline_mathml(<msub><mi>E</mi><mtext>s</mtext></msub>)}}} that penalize
lack of periodicity and smoothness, respectively. More precisely,
{{{inline_mathml(<msub><mi>E</mi><mtext>p</mtext></msub>)}}}
(resp. {{{inline_mathml(<msub><mi>E</mi><mtext>s</mtext></msub>)}}}) is greater
for less periodic (resp. less smooth) {{{inline_mathml(<mi>p</mi>)}}}
(resp. {{{inline_mathml(<mi>s</mi>)}}}). The periodic-plus-smooth decomposition
of an image {{{inline_mathml(<mi>u</mi>)}}} is then defined as the pair of
images {{{inline_mathml(<mfenced><mi>p</mi><mi>s</mi></mfenced>)}}} that
minimize the total energy
{{{inline_mathml(<mrow><mrow><mi>E</mi><mo>&af;</mo><mrow><mo>(</mo><mrow><mi>p</mi><mo>\,</mo><mi>s</mi></mrow><mo>)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>E</mi><mtext>p</mtext></msub><mo>&af;</mo><mrow><mo>(</mo><mi>p</mi><mo>)</mo></mrow></mrow><mo>+</mo><mrow><msub><mi>E</mi><mtext>s</mtext></msub><mo>&af;</mo><mrow><mo>(</mo><mi>s</mi><mo>)</mo></mrow></mrow></mrow>)}}}
under the constraints
{{{inline_mathml(<mrow><mi>u</mi><mo>=</mo><mi>p</mi><mo>+</mo><mi>s</mi></mrow>)}}}
and
{{{inline_mathml(<mrow><mrow><mi>mean</mi><mo>&af;</mo><mfenced><mi>s</mi></mfenced></mrow><mo>=</mo><mn>0</mn></mrow>)}}}. The
remainder of this post is dedicated to defining the energies
{{{inline_mathml(<msub><mi>E</mi><mtext>p</mtext></msub>)}}} and
{{{inline_mathml(<msub><mi>E</mi><mtext>s</mtext></msub>)}}}

* How to penalize lack of periodicity?

For each pixel located at the boundary of an image, we compute the sum of
squared differences (SSD) with /indirect/ neighbors. The sum of all these SSDs
is the energy of the periodic component. Note that /direct/ neighbors are
excluded from this sum, as we focus here on the jumps across image
boundaries. This leads to the following expression

#+BEGIN_EXPORT html
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnspacing="0em" columnalign="right left" displaystyle="true">
    <mtr>
      <mtd>
        <mrow>
          <msub>
            <mi>E</mi>
            <mtext>p</mtext>
          </msub>
          <mo>&ApplyFunction;</mo>
          <mfenced>
            <mi>p</mi>
          </mfenced>
        </mrow>
        <mo>=</mo>
      </mtd>
      <mtd>
        <munder accentunder="true">
          <!-- top-left corner -->
          <mrow>
            <!-- (p[m-1, 0]-p[0, 0])^2 -->
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
            <mo>+</mo>
            <!-- (p[0, n-1]-p[0, 0])^2 -->
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
          </mrow>
          <munder accentunder="true">
            <mo>&UnderBrace;</mo>
            <mtext>top-left corner</mtext>
          </munder>
        </munder>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd>
        <mo>+</mo>
        <munder accentunder="true">
          <!-- top-right corner -->
          <mrow>
            <!-- (p[0, 0]-p[0, n-1])^2 -->
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
            <mo>+</mo>
            <!-- (p[0, n-1]-p[0, 0])^2 -->
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
          </mrow>
          <munder accentunder="true">
            <mo>&UnderBrace;</mo>
            <mtext>top-right corner</mtext>
          </munder>
        </munder>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd>
        <mo>+</mo>
        <munder accentunder="true">
          <!-- bottom-left corner -->
          <mrow>
            <!-- (p[0, 0]-p[m-1, 0])^2 -->
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
            <mo>+</mo>
            <!-- (p[m-1, n-1]-p[m-1, 0])^2 -->
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
          </mrow>
          <munder accentunder="true">
            <mo>&UnderBrace;</mo>
            <mtext>bottom-left corner</mtext>
          </munder>
        </munder>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd>
        <mo>+</mo>
        <munder accentunder="true">
          <!-- bottom-right corner -->
          <mrow>
            <!-- (p[0, n-1]-p[m-1, n-1])^2 -->
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
            <mo>+</mo>
            <!-- (p[m-1, 0]-p[m-1, n-1])^2 -->
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
          </mrow>
          <munder accentunder="true">
            <mo>&UnderBrace;</mo>
            <mtext>bottom-right corner</mtext>
          </munder>
        </munder>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd>
        <mo>+</mo>
        <munder accentunder="true">
          <!-- sum((p[i, n-1]-p[i, 0])**2, i, 1, m-2) -->
          <mrow>
            <munderover>
              <mo>&sum;</mo>
              <mrow>
                <mi>i</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mrow>
                <mi>m</mi>
                <mo>-</mo>
                <mn>2</mn>
              </mrow>
            </munderover>
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mi>i</mi>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mi>i</mi>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
          </mrow>
          <munder accentunder="true">
            <mo>&UnderBrace;</mo>
            <mtext>left column</mtext>
          </munder>
        </munder>
        <mo>+</mo>
        <munder accentunder="true">
          <!-- sum((p[i, 0]-p[i, n-1])**2, i, 1, m-2) -->
          <mrow>
            <munderover>
              <mo>&sum;</mo>
              <mrow>
                <mi>i</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mrow>
                <mi>m</mi>
                <mo>-</mo>
                <mn>2</mn>
              </mrow>
            </munderover>
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mi>i</mi>
                      <mo>,</mo>
                      <mn>0</mn>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mi>i</mi>
                      <mo>,</mo>
                      <mrow>
                        <mi>n</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
          </mrow>
          <munder accentunder="true">
            <mo>&UnderBrace;</mo>
            <mtext>right column</mtext>
          </munder>
        </munder>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd>
        <mo>+</mo>
        <munder accentunder="true">
          <!-- sum((p[m-1, j]-p[0, j])**2, j, 1, n-2) -->
          <mrow>
            <munderover>
              <mo>&sum;</mo>
              <mrow>
                <mi>j</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mrow>
                <mi>n</mi>
                <mo>-</mo>
                <mn>2</mn>
              </mrow>
            </munderover>
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mi>j</mi>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mi>j</mi>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
          </mrow>
          <munder accentunder="true">
            <mo>&UnderBrace;</mo>
            <mtext>top row</mtext>
          </munder>
        </munder>
        <mo>+</mo>
        <munder accentunder="true">
          <!-- sum((p[0, j]-p[m-1, j])**2, j, 1, n-2) -->
          <mrow>
            <munderover>
              <mo>&sum;</mo>
              <mrow>
                <mi>j</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mrow>
                <mi>n</mi>
                <mo>-</mo>
                <mn>2</mn>
              </mrow>
            </munderover>
            <msup>
              <mfenced>
                <mrow>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mi>j</mi>
                    </mrow>
                  </msub>
                  <mo>-</mo>
                  <msub>
                    <mi>p</mi>
                    <mrow>
                      <mrow>
                        <mi>m</mi>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mi>j</mi>
                    </mrow>
                  </msub>
                </mrow>
              </mfenced>
              <mn>2</mn>
            </msup>
          </mrow>
          <munder accentunder="true">
            <mo>&UnderBrace;</mo>
            <mtext>bottom row</mtext>
          </munder>
        </munder>
        <mtext>,</mtext>
      </mtd>
    </mtr>
  </mtable>
</mrow>
</math>
#+END_EXPORT

which reduces to

#+BEGIN_EXPORT html
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <msub>
      <mi>E</mi>
      <mtext>p</mtext>
    </msub>
    <mo>&ApplyFunction;</mo>
    <mfenced>
      <mi>p</mi>
    </mfenced>
  </mrow>
  <mo>=</mo>
  <!-- sum((p[i, n-1]-p[i, 0])**2, i, 1, m-2) -->
  <mrow>
    <mn>2</mn>
    <mo>&InvisibleTimes;</mo>
    <munderover>
      <mo>&sum;</mo>
      <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
      </mrow>
      <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
      </mrow>
    </munderover>
    <msup>
      <mfenced>
        <mrow>
          <msub>
            <mi>p</mi>
            <mrow>
              <mi>i</mi>
              <mo>,</mo>
              <mrow>
                <mi>n</mi>
                <mo>-</mo>
                <mn>1</mn>
              </mrow>
            </mrow>
          </msub>
          <mo>-</mo>
          <msub>
            <mi>p</mi>
            <mrow>
              <mi>i</mi>
              <mo>,</mo>
              <mn>0</mn>
            </mrow>
          </msub>
        </mrow>
      </mfenced>
      <mn>2</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <!-- sum((p[m-1, j]-p[0, j])**2, j, 1, n-2) -->
  <mrow>
    <mn>2</mn>
    <mo>&InvisibleTimes;</mo>
    <munderover>
      <mo>&sum;</mo>
      <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>0</mn>
      </mrow>
      <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
      </mrow>
    </munderover>
    <msup>
      <mfenced>
        <mrow>
          <msub>
            <mi>p</mi>
            <mrow>
              <mrow>
                <mi>m</mi>
                <mo>-</mo>
                <mn>1</mn>
              </mrow>
              <mo>,</mo>
              <mi>j</mi>
            </mrow>
          </msub>
          <mo>-</mo>
          <msub>
            <mi>p</mi>
            <mrow>
              <mn>0</mn>
              <mo>,</mo>
              <mi>j</mi>
            </mrow>
          </msub>
        </mrow>
      </mfenced>
      <mn>2</mn>
    </msup>
  </mrow>
  <mtext>.</mtext>
</mrow>
</math>
#+END_EXPORT

* How to penalize lack of smoothness?

At this point, you might have guessed that smoothness is measured through the
sum of squared differences between /direct/ neighbors

#+BEGIN_EXPORT html
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <msub>
      <mi>E</mi>
      <mtext>s</mtext>
    </msub>
    <mo>&ApplyFunction;</mo>
    <mfenced>
      <mi>s</mi>
    </mfenced>
  </mrow>
  <mo>=</mo>
  <mrow>
    <munderover>
      <mo>&sum;</mo>
      <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
      </mrow>
      <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
      </mrow>
    </munderover>
    <mo>&InvisibleTimes;</mo>
    <munderover>
      <mo>&sum;</mo>
      <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>0</mn>
      </mrow>
      <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
      </mrow>
    </munderover>
    <mfenced open="[" close="]">
      <mrow>
        <msup>
          <mfenced>
            <mrow>
              <msub>
                <mi>s</mi>
                <mrow>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>j</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                  </mrow>
                </mrow>
              </msub>
              <mo>-</mo>
              <msub>
                <mi>s</mi>
                <mrow>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>j</mi>
                </mrow>
              </msub>
            </mrow>
          </mfenced>
          <mn>2</mn>
        </msup>
        <mo>+</mo>
        <msup>
          <mfenced>
            <mrow>
              <msub>
                <mi>s</mi>
                <mrow>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>j</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                </mrow>
              </msub>
              <mo>-</mo>
              <msub>
                <mi>s</mi>
                <mrow>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>j</mi>
                </mrow>
              </msub>
            </mrow>
          </mfenced>
          <mn>2</mn>
        </msup>
        <mo>+</mo>
        <msup>
          <mfenced>
            <mrow>
              <msub>
                <mi>s</mi>
                <mrow>
                  <mrow>
                    <mi>i</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                  </mrow>
                  <mo>,</mo>
                  <mi>j</mi>
                </mrow>
              </msub>
              <mo>-</mo>
              <msub>
                <mi>s</mi>
                <mrow>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>j</mi>
                </mrow>
              </msub>
            </mrow>
          </mfenced>
          <mn>2</mn>
        </msup>
        <mo>+</mo>
        <msup>
          <mfenced>
            <mrow>
              <msub>
                <mi>s</mi>
                <mrow>
                  <mrow>
                    <mi>i</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                  <mo>,</mo>
                  <mi>j</mi>
                </mrow>
              </msub>
              <mo>-</mo>
              <msub>
                <mi>s</mi>
                <mrow>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>j</mi>
                </mrow>
              </msub>
            </mrow>
          </mfenced>
          <mn>2</mn>
        </msup>
      </mrow>
    </mfenced>
    <mtext>,</mtext>
  </mrow>
</math>
#+END_EXPORT

where we have defined the following ghost cells

#+BEGIN_EXPORT html
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnspacing="2em">
    <mtr>
      <mtd>
        <msub>
          <mn>s</mn>
          <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mo>-</mo>
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>=</mo>
        <msub>
          <mn>s</mn>
          <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mn>0</mn>
          </mrow>
        </msub>
        <mtext>,</mtext>
      </mtd>
      <mtd>
        <msub>
          <mn>s</mn>
          <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mi>n</mi>
          </mrow>
        </msub>
        <mo>=</mo>
        <msub>
          <mn>s</mn>
          <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
          </mrow>
        </msub>
        <mtext>,</mtext>
      </mtd>
      <mtd>
        <msub>
          <mn>s</mn>
          <mrow>
            <mo>-</mo>
            <mn>1</mn>
            <mo>,</mo>
            <mi>j</mi>
          </mrow>
        </msub>
        <mo>=</mo>
        <msub>
          <mn>s</mn>
          <mrow>
            <mn>0</mn>
            <mo>,</mo>
            <mi>j</mi>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <mtext>and</mtext>
      </mtd>
      <mtd>
        <msub>
          <mn>s</mn>
          <mrow>
            <mi>m</mi>
            <mo>,</mo>
            <mi>j</mi>
          </mrow>
        </msub>
        <mo>=</mo>
        <msub>
          <mn>s</mn>
          <mrow>
            <mi>m</mi>
            <mo>-</mo>
            <mn>1</mn>
            <mo>,</mo>
            <mi>j</mi>
          </mrow>
        </msub>
        <mtext>,</mtext>
      </mtd>
    </mtr>
  </mtable>
</math>
#+END_EXPORT

in order to make sure that indirect neighbors are indeed excluded. It is readily
observed that in the above sum, each pair of direct neighbors appears exactly
twice. In other words,

#+BEGIN_EXPORT html
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <msub>
      <mi>E</mi>
      <mtext>s</mtext>
    </msub>
    <mo>&ApplyFunction;</mo>
    <mfenced>
      <mi>s</mi>
    </mfenced>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mn>2</mn>
    <mo>&InvisibleTimes;</mo>
    <munderover>
      <mo>&sum;</mo>
      <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
      </mrow>
      <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>2</mn>
      </mrow>
    </munderover>
    <mo>&InvisibleTimes;</mo>
    <munderover>
      <mo>&sum;</mo>
      <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>0</mn>
      </mrow>
      <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
      </mrow>
    </munderover>
    <mrow>
      <msup>
        <mfenced>
          <mrow>
            <msub>
              <mi>s</mi>
              <mrow>
                <mrow>
                  <mi>i</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
                <mo>,</mo>
                <mi>j</mi>
              </mrow>
            </msub>
            <mo>-</mo>
            <msub>
              <mi>s</mi>
              <mrow>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
              </mrow>
            </msub>
          </mrow>
        </mfenced>
        <mn>2</mn>
      </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
      <mn>2</mn>
      <mo>&InvisibleTimes;</mo>
      <munderover>
        <mo>&sum;</mo>
        <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>0</mn>
        </mrow>
        <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
        </mrow>
      </munderover>
      <mo>&InvisibleTimes;</mo>
      <munderover>
        <mo>&sum;</mo>
        <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>0</mn>
        </mrow>
        <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>2</mn>
        </mrow>
      </munderover>
      <msup>
        <mfenced>
          <mrow>
            <msub>
              <mi>s</mi>
              <mrow>
                <mi>i</mi>
                <mo>,</mo>
                <mrow>
                  <mi>j</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </mrow>
            </msub>
            <mo>-</mo>
            <msub>
              <mi>s</mi>
              <mrow>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
              </mrow>
            </msub>
          </mrow>
        </mfenced>
        <mn>2</mn>
      </msup>
    </mrow>
    <mtext>.</mtext>
  </mrow>
</math>
#+END_EXPORT

* Python implementation

Implementation of the total energy {{{inline_mathml(<mrow><mrow><mi>E</mi><mo>&af;</mo><mrow><mo>(</mo><mrow><mi>p</mi><mo>\,</mo><mi>s</mi></mrow><mo>)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>E</mi><mtext>p</mtext></msub><mo>&af;</mo><mrow><mo>(</mo><mi>p</mi><mo>)</mo></mrow></mrow><mo>+</mo><mrow><msub><mi>E</mi><mtext>s</mtext></msub><mo>&af;</mo><mrow><mo>(</mo><mi>s</mi><mo>)</mo></mrow></mrow></mrow>)}}} is fairly trivial.

#+BEGIN_SRC python :results output code :exports results
  import inspect

  import moisan2011

  print(inspect.getsource(moisan2011.ssd))
  print()
  print(inspect.getsource(moisan2011.energy))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
def ssd(a, b):
    """Sum of squared differences."""
    delta2 = b-a
    delta2 *= delta2
    return np.sum(delta2)


def energy(p, s):
    """Return the total energy of the periodic-plus-smooth decomposition.

    The periodic and smooth components p and s are 2D arrays of
    float64. They should have the same shape, although this is not
    required by this function.  2D arrays.

    The energy is defined in Moisan (2011), Theorem 1. The
    contribution of the periodic component is

        E_p(p) = sum sum [p(x)-p(y)]**2,
                  x   y

    where the first sum is carried over all boundary pixels x, and the
    second sum is carried over the indirect neighbors y of x. The
    contribution of the smooth component is

        E_s(s) = sum sum [s(x)-s(y)]**2,
                  x   y

    where the first sum is carried over all pixels x, and the second
    sum is carried over the direct neighbors y of x. The total energy
    is then defined as

        E(p, s) = E_p(p) + E_s(s).
    """
    return 2*(ssd(p[:, 0], p[:, -1]) +
              ssd(p[0, :], p[-1, :]) +
              ssd(s[:-1, :], s[1:, :]) +
              ssd(s[:, :-1], s[:, 1:]))

#+END_SRC

* Conclusion

In the present post, we have defined the periodic-plus-smooth decomposition as
the minimizer of Moisan's energy, under the constraint that the average gray
level of the periodic component is equal to the average gray level of the
initial image.

Moisan ([[moisan2011:][2011]]) that this minimizer is explicit in Fourier space. However,
observing that Moisan's energy is a quadratic form, we will temporarily ignore
this result

In the [[sb-blog-next:][next instalment]] of this series, we will however temporarily ignore this
result, and optimize the total energy in the real space, using standard
iterative techniques. This will allow us to generate reference decompositions
that will eventually be used to set up unit tests in order to check our
implementation of Moisan's method.

#+BEGIN_SRC ipython :results output :results html :results string
  import numpy as np
  import sympy

  from scipy.ndimage import convolve

  k = np.array([[0, -1, 0],
                [-1, 4, -1],
                [0, -1, 0]], dtype=np.int32)

  m, n = 4, 5
  u = np.zeros((m, n), dtype=np.int32)

  output = sympy.zeros(m, n)
  for i in range(m):
      for j in range(n):
          u[i, j] = 1
          u_ij = sympy.Symbol('u{}{}'.format(i, j))
          output += u_ij*sympy.Matrix(convolve(u,k, mode='nearest'))
          u[i, j] = 0
  print('<math xmlns="http://www.w3.org/1998/Math/MathML">'+
        sympy.printing.mathml(output)+
        '</math>')
#+END_SRC

# Local Variables:
# eval: (sb-blog-init-data-dir)
# fill-column: 80
# End:
