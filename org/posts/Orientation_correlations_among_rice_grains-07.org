# -*- coding: utf-8; -*-
#+SETUPFILE: "../include/css-1.org"
#+SETUPFILE: "../include/mathjax.org"
#+TITLE: Orientation correlations among rice grains, part 7: analysis of the shape of the grains
#+DATE: [2015-12-01 Tue]
#+PROPERTY: header-args:ipython :session :eval no-export :exports both

#+BEGIN_SRC ipython :results output
  import os.path

  import h5py
  import scipy.ndimage

  filename = os.path.join('G:', 'sebastien', 'experimental_data',
                          'navier', 'riz', 'rice-bin_4x4x4.hdf5')

  with h5py.File(filename, 'r') as f:
      labels = np.asarray(f['labels'])

  print(labels.shape)

  indices = np.unique(labels)
  # Discard index 0, which is the background
  indices = indices[1:]
#+END_SRC

#+RESULTS:
: (172, 437, 436)

* Morphological description of the grains

** The direct approach

The direct (naive) approach will serve as a reference for a better approach. It will be illustrated on one grain only, which we first locate. The remainder of the analysis is then restricted to a ROI.

#+BEGIN_SRC ipython :results output
  index = 42
  slices = scipy.ndimage.find_objects(labels)[index-1]
  roi = labels[slices]
  print(slices)
#+END_SRC

#+RESULTS:
: (slice(0, 14, None), slice(173, 209, None), slice(83, 132, None))

The grain shape is then defined by =mask=, an array of booleans, where all voxels of the ROI that belong to the grain are set to =True=.

#+BEGIN_SRC ipython :results none
  mask = roi == index
#+END_SRC

The volume (in voxels) of the grain is then the sum of the above array

#+BEGIN_SRC ipython :results output
  vol_ref = mask.sum()
  print('Volume of grain {} = {} vox^3.'.format(index, vol_ref))
#+END_SRC

#+RESULTS:
: Volume of grain 42 = 7186 vox^3.

To compute the center of mass and inertia of the grain, we must define the coordinates of each voxel of the grain. To do so, we use the [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.mgrid.html][mgrid]] function

#+BEGIN_SRC ipython :results none
  coords = np.mgrid[slices].astype(np.float64)
#+END_SRC

The center of mass of the grain is then the sum of these coordinates divided by the total volume

#+BEGIN_SRC ipython :results output
  com_ref = np.sum(coords*mask, axis=(-1, -2, -3))/vol_ref
  print('Center of mass of grain {} = {} vox'.format(index, com_ref))
#+END_SRC

#+RESULTS:
: Center of mass of grain 42 = [   4.96688004  191.40801559  103.66824381] vox

Note that we multiplied by mask in order to keep only those voxels that belong to the grain. To compute the inertia of the grain, we first center the voxel coordinates with respect to the center of mass.

#+BEGIN_SRC ipython :results none
  coords -= com_ref[:, None, None, None]
#+END_SRC

We then compute the array coordinates cross-products =coords_xprod= defined as follows

#+BEGIN_EXAMPLE
coords_xprod[m, n, i, j, k] = coords[m, i, j, k]*coords[n, i, j, k]
#+END_EXAMPLE

(=i, j, k=: voxel indices; =m, n=: coordinates indices). The =coords_xprod= array is produced by the following line of code

#+BEGIN_SRC ipython :results none
  coords_xprod = coords[None, ...]*coords[:, None, ...]
#+END_SRC

#+BEGIN_SRC ipython :results output
  inertia_ref = np.sum(mask*coords_xprod, axis=(-1, -2,-3))
  print('Moments of inertia of grain {} (vox^5)'.format(index))
  print(inertia_ref)
#+END_SRC

#+RESULTS:
: Moments of inertia of grain 42 (vox^5)
: [[  73912.1174506   -47088.89229056  -71887.95797384]
:  [ -47088.89229056  434923.69830225  180875.70915669]
:  [ -71887.95797384  180875.70915669  893659.09323685]]

This is a bit tedious, isn't it? Besides, we should normally loop over the grains in order to carry out the analysis for all grains. Fortunately, =scipy.ndimage= defines the wonderful [[http://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.sum.html][sum]] function!

** Using the =scipy.ndimage.sum= function

This function will allow us to carry out the analysis over all grains simultaneously. We start with the volume, which is seen as

\begin{equation*}
\sum 1
\end{equation*}

where the sum is carried over all voxels of each grain.

#+BEGIN_SRC ipython :file ./tmp/volume_histogram.png
  ones = np.ones_like(labels, dtype=np.float64)
  vol = scipy.ndimage.sum(ones, labels, indices)
  plt.hist(vol, range=(0, 12000), bins=30)
#+END_SRC

#+RESULTS:
[[file:./tmp/volume_histogram.png]]

And we can check that the value we found for grain 42 is correct

#+BEGIN_SRC ipython :results output
  print('Volume of grain {}'.format(index))
  print('    expected   = {}'.format(vol_ref))
  print('    actual     = {}'.format(vol[index-1]))
#+END_SRC

#+RESULTS:
: Volume of grain 42
:     expected   = 7186
:     actual     = 7186.0

For the center of mass, we can use the [[http://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.center_of_mass.html][center_of_mass]] function

#+BEGIN_SRC ipython :results output
  com = np.asarray(scipy.ndimage.center_of_mass(ones, labels, indices))
  print('Center of mass of grain {}'.format(index))
  print('    expected   = {}'.format(com_ref))
  print('    actual     = {}'.format(com[index-1]))
#+END_SRC

#+RESULTS:
: Center of mass of grain 42
:     expected   = [   4.96688004  191.40801559  103.66824381]
:     actual     = [   4.96688004  191.40801559  103.66824381]

Finally, the moments of inertia are seen as the sum of $x_ix_j$ carried over all voxels of the grain ($x_i$ is the $i$-th coordinate of the voxel). Therefore, we first build the array =coords= of voxel coordinates.

#+BEGIN_SRC ipython :results none
  coords = np.mgrid[[slice(n) for n in labels.shape]]
#+END_SRC

We should normally measure the coordinates with respect to the center of mass of each grain. This would require to subtract to =coords= a value which depend on the grain. Rather, we use the following identity

\begin{equation*}
I_{ij}=\sum\left(x_i-\overline x_j\right)\left(x_j-\overline x_j\right)=\sum x_ix_j+V\overline x_i\overline x_j,
\end{equation*}

where $V$ denotes the volume of the grain, $\overline x_i$ the coordinates of its center of mass, and $x_i$ the coordinates of a voxel of the grain. Using the =scipy.ndimage.sum= function, the code reads

#+BEGIN_SRC ipython :results none
  inertia = np.empty((indices.size, 3, 3), dtype=np.float64)

  for i in range(3):
      for j in range(3):
          xi = coords[i, :]
          xj = coords[j, :]
          inertia[:, i, j] = (scipy.ndimage.sum(xi*xj, labels, indices) -
                              vol*com[:, i]*com[:, j])
#+END_SRC

And we can again check that the result is correct for grain #42.

#+BEGIN_SRC ipython :results output
  print('Moments of inertia of grain {}'.format(index))
  print('    expected =')
  print(inertia_ref)
  print('    actual =')
  print(inertia[index-1])
#+END_SRC

#+RESULTS:
: Moments of inertia of grain 42
:     expected =
: [[  73912.1174506   -47088.89229056  -71887.95797384]
:  [ -47088.89229056  434923.69830225  180875.70915669]
:  [ -71887.95797384  180875.70915669  893659.09323685]]
:     actual =
: [[  73912.1174506   -47088.89229057  -71887.95797384]
:  [ -47088.89229057  434923.69830227  180875.70915669]
:  [ -71887.95797384  180875.70915669  893659.09323685]]

* Orientation of the grains

#+BEGIN_SRC ipython :results none
  inertia_principal, inertia_direction = np.linalg.eig(inertia)
#+END_SRC

It turns out that some of the eigenvalues that are found are negative

#+BEGIN_SRC ipython :results output
  i = np.nonzero(inertia_principal < 0)
  print(i)
#+END_SRC

#+RESULTS:
: (array([  13, 1959], dtype=int64), array([2, 2], dtype=int64))

However, these eigenvalues are very small

#+BEGIN_SRC ipython :results output
  print(inertia_principal[i])
#+END_SRC

#+RESULTS:
: [ -4.88083585e-22  -1.02671800e-22]

and we set them to zero

#+BEGIN_SRC ipython :results none
  inertia_principal[i] = 0
#+END_SRC

The /orientation/ $\vec n$ of the grain is defined as the eigenvector associated with the largest principal moment of inertia.

#+BEGIN_SRC ipython :results none
  i = np.argmax(inertia_principal, axis=1)
  n = inertia_direction[i]
#+END_SRC

To compute the radii $a>b>c$ of the equivalent ellipsoid, we recall that its volume and principal inertia are

\begin{align*}
  V &= \frac{4\pi}3 abc,\\
  I_a &= \frac{4\pi}{15}a^3bc=\frac{Va^2}5,\\
  I_b &= \frac{4\pi}{15}ab^3c=\frac{Vb^2}5,\\
  I_c &= \frac{4\pi}{15}abc^3=\frac{Vc^2}5.
\end{align*}

The above expressions can be retrieved from [[https://en.wikipedia.org/wiki/Ellipsoid#Dynamical_properties][Wikipedia]]. For example

\begin{align*}
I_a &= \int x^2\,\diff x\,\diff y\,\diff z\\
    &= \frac12\int\left[\left(x^2+y^2\right)+\left(x^2+z^2\right)-\left(y^2+z^2\right)\right]\\
    &= \frac12\left(I_{zz}+I_{yy}-I_{xx}\right).
\end{align*}

Then, from the volume $V$ and the principal inertia $I_a$, $I_b$ and $I_c$ of each grain, the radii are retrieved as follows

\begin{align*}
a &= \sqrt{\frac{5I_a}V}, & b &= \sqrt{\frac{5I_b}V}, & c &= \sqrt{\frac{5I_c}V}.
\end{align*}

The following code snippet computes the radii of each grain, and sorts them in ascending order.

#+BEGIN_SRC ipython :results none
  radius = np.sort(np.sqrt(5*inertia_principal/vol[:, None]))
#+END_SRC

It is now possible to visualize these radii as histograms

#+BEGIN_SRC ipython :file ./tmp/radii_histogram.png
  width, height = plt.rcParams['figure.figsize']
  fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(2*width, height))
  ax1.hist(radius[:, -1], range=(0, 40), bins=40)
  ax1.set_xlabel('a')
  ax1.set_ylabel('Number')
  ax2.hist((radius[:, -2], radius[:-1]), range=(0, 20), bins=20)
  ax2.set_xlabel('b, c')
  ax2.set_ylabel('Number')
#+END_SRC

#+RESULTS:
[[file:./tmp/radii_histogram.png]]

It is observed that, while the length of most grains is about 2Ã—27=54 pixels (about 6.5 mm), a significant number of grains are very small. There are two possible explanations for this

  1. some grains where broken in smaller pieces,
  2. our [[file:20150930-Orientation_correlations_among_rice_grains-06.org][segmentation]] was not perfect (over-segmentation might have occured).

My guess is that it is in fact a little bit of both. One possible remedy would be to filter out those grains that are too small in the subsequent analysis. We will not go into such degree of refinment.
