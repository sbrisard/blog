# -*- coding: utf-8; -*-
#+SETUPFILE: "../header.org"
#+SETUPFILE: "../header-1.org"
#+INCLUDE: "../navbar-1.org"
#+TITLE: Review of "Learning Cython Programming"
#+DATE: <2014-01-26 Sun>

I have recently been offered by [[http://www.packtpub.com/][Packt Publishing]] a free electronic copy of the book /[[http://www.packtpub.com/learning-cython-programming/book][Learning Cython Programming]]/ (by Philip Herron) for me to review. This offer arrived just in time for me, as I had just heard of it and decided to give it a go. The situation is a bit awckward, though, as I have to admit I was a bit disappointed by the book.@@html:<!-- more -->@@

Let me first say that I am no expert in [[http://cython.org/][Cython]] programming, although I use it on a daily basis. I discovered this superset of the [[http://www.python.org/][Python]] programming language in august 2013, and soon came to love it. I'm currently developping a numerical code in Python, using Cython for efficiency where necessary (I hope to report on this code soon in this blog). Therefore, I am a relatively new Cython user, and had quite high expectations from this book.

The book is rather clear and short (the PDF file contains 110 pages), which can be attractive to absolute beginners. This also means that the book is not an in-depth presentation of the language and the possibility it offers. Very broadly speaking, there are two potential uses of Cython
  - as a way to write C extensions/interface with pure C code,
  - as a way to call the Python machinery from within pure C code.

Although the author exposes both sides of the coin, he is more interested in the latter use, as clearly indicated by the subtitle of the book (/Expand your existing legacy applications in C using Python/). This probably explains why the first example is compiled with... a =Makefile=!!! 'Come on', I thought, 'use =distutils=!'

I am personally more interested in the first use of Cython, as a way to speed things up in my Python code. Part of my frustration comes from the fact that speed is barely mentioned in the whole book. However, to be fair, I found it interesting to see other potential uses of the language (e.g. calling a high-level language from within a low-level code).

After a few words of introduction, and hints about installing Cython, *Chapter 1* (/Cython won't Bite/) is based on the classical "Hello World" program to demonstrate how to call Cython code (that is, really pure C) code from within Python. Let's admit it, we would have been disappointed if the author had used any other example to start with! If you've never used Cython before, this chapter provides a concise summary of the steps necessary to produce a Python module written in Cython. There is a catch, though: it assumes that you are using GNU tools. So, if you are working under Windows, you are pretty much left on your own, appart from a link to the [[https://github.com/cython/cython/wiki/InstallingOnWindows][Wiki]] (my personal advice: [[https://store.continuum.io/cshop/anaconda/][Anaconda]] rocks! On top of that, install your own, separate distribution of [[http://www.mingw.org/][MinGW]] -- not the one which comes as a =conda= package).

In *chapter 2*, the author explores the C side of things: how to call the Python API from within pure C code, without the burden (among others) of refcounting the objects. He also takes a closer look at the =cdef= and =public= keywords. More interestingly, he shows how =struct=, =typedef= and =enum= translate into Cython. Regarding the latter, I think the author should have explained how an =enum=
 is then passed to Python. This might be a silly question, but I did not find the answer in the book. This chapter closes on build systems, namely =distutils= and =autotools=. While I'm more interested in the former, I think the latter would prove extremely valuable to some readers.

 In *chapter 3*, speed gets mentioned, albeit in a very superficial way. The author shows that if you Cythonize a pure Python code, you can get /some/ speedup. What the author fails to demonstrate, is that you can get /dramatic/ speedups the moment you start /typing/ (meaning, giving a type to) your variables. Then, the author shows how to create extension types in Cython, and how memory management is kept to a minimum thanks to the special methods =__cinit__()= and =__dealloc__()=. I did not find the example that follows about extending Tmux with Cython very helpful: lots of code, but not many explanations!

*Chapter 4* is dedicated to debugging. Although very brief, I found it (in particular, the section on /Cython caveats/) useful.

*Chapter 5* addresses advanced topics, and that chapter alone was the reason for which I initially wanted to buy this book. I have to say I was fairly disappointed, as the matters discussed in this chapter would have deserved much, much more space. I don't use C++ myself, but judging by the amount of messages regarding C++ and Cython on the =cython-users= mailing-list, I think that interfacing with C++ can sometimes be difficult. In this book, the section on templates is only about ten lines! As for the section on the GIL, this is pretty useless material. For the time being, I have not yet used the =with gil/with no gil= key words in my code, for fear of making a mistake... Unfortunately, after reading this book, I'm still not sure where I should or should not release the GIL.

*Chapter 6* (/Further reading/) has some interesting links. But this does not make up for all the information I did /not/ find in this book.

To sum up, I would recommend this book only to those of you who have /never/ used Cython. The moment you have written your first extension type in Cython, you no longer need this book, and you are probably better off with good resources available on the web (including the [[http://docs.cython.org/][official documentation]] of course, a truly excellent tutorial session at [[http://conference.scipy.org/scipy2013/tutorial_detail.php?id=105][SciPy 2013]] by Kurt Smith, and a [[http://blog.enthought.com/general/advanced-cython-recorded-webinar-typed-memoryviews/][webinar on memoryviews]] by the same Kurt Smith). As far as I am concerned, I will not be able to draw much inspiration from /Learning Cython Programming/, although I certainly do not see myself as an advanced user of Cython. Still, I will keep a few sections in mind, in particular
  - /General Cython caveats/: for example, the C-like =for=-loop (see p. 58), which I was not aware of,
  - /Cython typing via annotations/: this might be useful to run such tools as =pep8= or =pylint= on Cython source files. Not sure it will work, but worth trying.

I hope that this review will be useful to some of you. I would like to thank [[http://www.packtpub.com/][Packt Publishing]] for sending me a copy of this book. I think that for a publisher to ask for independent reviews from the community is a very sensible approach. Although this book was not the best I've ever read, I have happily bought other books from Packt, and will continue doing so in the future.
