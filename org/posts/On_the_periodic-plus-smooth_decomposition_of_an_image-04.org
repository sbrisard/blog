# -*- coding: utf-8; fill-column: 79 -*-
#+SETUPFILE: "../include/css-1.org"
#+SETUPFILE: "../include/mathjax.org"
#+TITLE: On the periodic-plus-smooth decomposition of an image, part 4: implementation of the linear operators
#+DATE: [2018-01-22 Mon]
#+LINK: moisan2011   https://doi.org/10.1007/s10851-010-0227-1
#+LINK: sb-blog-prev ./On_the_periodic-plus-smooth_decomposition_of_an_image-03.org
#+LINK: sb-blog-next ./On_the_periodic-plus-smooth_decomposition_of_an_image-05.org
#+LINK: sb-blog-data-dir ./On_the_periodic-plus-smooth_decomposition_of_an_image/
#+PROPERTY: header-args:ipython :session :eval no-export :exports both

* Implementation of the operators /Q₁/ and /Q₂/

The operators $A$ and $B$ defined above are linear operators. They may in
principle be implemented as matrices. However, doing so would be a terrible
idea. First, because the matrix would be huge ($mn\times mn$ coefficients for a
$m\times n$ image), and second, because a new matrix would need to be created
each time we work with a different image.

Instead, we will adopt here a /matrix-free/ approach, where $A$ and $B$ are
implemented as =LinearOperator= from the =scipy.sparse.linalg= module (see
[[https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator][documentation]]). Essentially, what this means is that $A$ and $B$ are
/functions/ that perform the matrix-vector product. Often times, this is enough
to perform fairly complex linear algebra operations. In particular, solving
linear systems that involve $A$ and $B$ can then be done by means of
[[https://en.wikipedia.org/wiki/Iterative_method#Linear_systems][iterative linear solvers]], such as the [[https://en.wikipedia.org/wiki/Conjugate_gradient_method][conjugate gradient method]]. Interesting references on this topic are the book by Y. Saad:
[[https://doi.org/10.1137/1.9780898718003][Iterative Methods for Sparse Linear Systems]] and the book by Barrett /et al./:
[[http://epubs.siam.org/doi/book/10.1137/1.9781611971538][Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods]] (also freely available [[http://www.netlib.org/templates/][here]]).

It should be noted that instances of =LinearOperator= (in the Scipy sense)
operate on 1D-vectors. Therefore, 2D images must be converted to 1D vectors
each time linear operators are to ben invoked. We will assume C-ordering in the
implementation below.

We first create the base class =ImageLinearOperator=, that defines linear
operators that operate on images. These operators store the shape of the image.

#+BEGIN_SRC ipython :exports results :results output code
  import inspect

  import moisan2011

  print(inspect.getsource(moisan2011.ImageLinearOperator))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC ipython
class ImageLinearOperator(scipy.sparse.linalg.LinearOperator):
    """Linear operator that operate on images.

    This class defines a linear operator (in the SciPy sense) that
    operates on n-dimensional images, the shape of which is passed to
    the initializer

    >>> a = ImageLinearOperator(10, 5)
    >>> a.img_shape
    (10, 5)
    >>> a.shape
    (50, 50)

    SciPy linear operators operate on one-dimensional vectors: the
    methods _matvec and _adjoint implemented by each subclass must
    therefore first reshape the input array to a n-dimensional
    image. By convention, C-ordering will always be assumed.

        y = numpy.zeros_like(x)
        x2 = x.reshape(self.img_shape)
        y2 = y.reshape(self.img_shape)
        ......................
        # Operate on x2 and y2
        ......................
        return y

    Alternatively, developers may implement the method _apply that
    operates on n-dimensional images: the default implementation of
    _matvec calls this method on the input vector, suitably reshaped to
    a n-dimensional image.
    """
    def __init__(self, *args):
        self.img_shape = tuple(int(n) for n in args)
        n = np.product(self.img_shape)
        shape = (n, n)
        dtype = np.dtype(np.float64)
        super().__init__(dtype, shape)

    def _matvec(self, x):
        y = np.zeros_like(x)
        x2 = x.reshape(self.img_shape)
        y2 = y.reshape(self.img_shape)
        self.ddot(x2, y2)
        return y

    def _apply(x, y=None):
        """Apply this operator on the input image x.

        The shape of x must be self.img_shape. The returned array has
        same shape as x.

        If specified, the optional argument y must be an array of same
        shape as x. It is modified in-place, and a reference to y is
        returned.
        """
        raise NotImplementedError()

#+END_SRC

Then, implementation of the $Q_1$ operator is fairly simple.

#+BEGIN_SRC ipython :exports results :results output code
  import inspect

  import moisan2011

  print(inspect.getsource(moisan2011.OperatorQ1))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC ipython
class OperatorQ1(ImageLinearOperator):
    u"""Implementation of Q₁ as a ``ImageLinearOperator``.

    Q₁ is defined by Eq. (9) of Moisan (2011)

        F(s) = (u-s)ᵀ·Q₁·(u-s)+sᵀ·Q₂·s,

    where F(s) is the function to be minimized, defined by Eq. (8)

        F(s) = E(u-s, s) + mean(s)².

    Image p = u-s must be passed as a 1-dimensional vector. Internally,
    it is reshaped to a two-dimensional image (the shape of which is
    passed to the initializer), **assuming C-ordering**.
    """
    def __init__(self, *args):
        super().__init__(*args)

    def _apply(self, x, y=None):
        if y is None:
            y = np.zeros_like(x)

        dx = 2.0*(x[:, 0]-x[:, -1])
        y[:, 0] = dx
        y[:, -1] = -dx

        dx = 2.0*(x[0, :]-x[-1, :])
        y[0, :] += dx
        y[-1, :] -= dx

        return y

    def _adjoint(self):
        return self

#+END_SRC

Note that $Q_1$ is symmetric: the =_adjoint= method simply returns =self=.
